# Generated by CodiumAI
import pytest

from mappingtools import MappingCollector, MappingCollectorMode


# Collects key-value pairs from a list of tuples
def test_collect_from_list_of_tuples():
    collector = MappingCollector(mode=MappingCollectorMode.ALL)
    data = [('a', 1), ('b', 2)]
    collector.collect(data)
    assert collector.mapping == {'a': [1], 'b': [2]}


# Adds collected pairs to the internal mapping
def test_adds_collected_pairs_to_internal_mapping():
    collector = MappingCollector(mode=MappingCollectorMode.ALL)
    data = [('a', 1), ('b', 2)]
    collector.collect(data)
    assert 'a' in collector.mapping and 'b' in collector.mapping


# Works with different iterable types like lists, sets, and generators
def test_works_with_different_iterable_types():
    collector = MappingCollector(mode=MappingCollectorMode.ALL)
    data_list = [('a', 1), ('b', 2)]
    data_set = {('c', 3), ('d', 4)}
    data_gen = (x for x in [('e', 5), ('f', 6)])
    collector.collect(data_list)
    collector.collect(data_set)
    collector.collect(data_gen)
    assert collector.mapping == {'a': [1], 'b': [2], 'c': [3], 'd': [4], 'e': [5], 'f': [6]}


# Handles empty iterables without errors
def test_handles_empty_iterables():
    collector = MappingCollector(mode=MappingCollectorMode.ALL)
    data = []
    collector.collect(data)
    assert collector.mapping == {}


# Collects from an iterable with duplicate keys
def test_collects_from_iterable_with_duplicate_keys():
    collector = MappingCollector(mode=MappingCollectorMode.ALL)
    data = [('a', 1), ('a', 2)]
    collector.collect(data)
    assert collector.mapping == {'a': [1, 2]}


# Collects from an iterable with mixed data types
def test_collects_from_iterable_with_mixed_data_types():
    collector = MappingCollector(mode=MappingCollectorMode.ALL)
    data = [('a', 1), ('b', 'string'), ('c', 3.14)]
    collector.collect(data)
    assert collector.mapping == {'a': [1], 'b': ['string'], 'c': [3.14]}


# Collects from an iterable with None values
def test_collects_from_iterable_with_none_values():
    collector = MappingCollector(mode=MappingCollectorMode.ALL)
    data = [('a', None), ('b', None)]
    collector.collect(data)
    assert collector.mapping == {'a': [None], 'b': [None]}


# Collects from an iterable with very large data sets
def test_collects_from_iterable_with_large_data_sets():
    collector = MappingCollector(mode=MappingCollectorMode.ALL)
    data = [(str(i), i) for i in range(10000)]
    collector.collect(data)
    assert len(collector.mapping) == 10000


# Collects from an iterable with invalid data types
def test_collects_from_iterable_with_invalid_data_types():
    collector = MappingCollector(mode=MappingCollectorMode.ALL)
    data = ['a', 1, 0.05]

    with pytest.raises(ValueError):
        collector.collect(data)


# Collects from an iterable with nested iterables
def test_collects_from_iterable_with_nested_iterables():
    collector = MappingCollector(mode=MappingCollectorMode.ALL)
    data = [('a', (1, 2)), ('b', [3, 4])]
    collector.collect(data)
    assert collector.mapping == {'a': [(1, 2)], 'b': [[3, 4]]}


# Collects from an iterable with special characters in keys or values
def test_collects_from_iterable_with_special_characters():
    collector = MappingCollector(mode=MappingCollectorMode.ALL)
    data = [('!@#$', '%^&*'), ('()_+', '{}|')]
    collector.collect(data)
    assert collector.mapping == {'!@#$': ['%^&*'], '()_+': ['{}|']}
