# Generated by CodiumAI
from collections import Counter

import pytest
from mappingtools import CategoryCounter

fruits = ['apple', 'apricot', 'banana', 'cherry', 'pear', 'pineapple', 'plum', 'banana']

expected_total = Counter({
    'banana': 2,
    'apple': 1,
    'apricot': 1,
    'cherry': 1,
    'pear': 1,
    'pineapple': 1,
    'plum': 1
})

expected_counter = {
    'char_count': {
        4: Counter({'pear': 1, 'plum': 1}),
        5: Counter({'apple': 1}),
        6: Counter({'banana': 2, 'cherry': 1}),
        7: Counter({'apricot': 1}),
        9: Counter({'pineapple': 1})
    },
    'unique_char_count': {
        3: Counter({'banana': 2}),
        4: Counter({'apple': 1, 'pear': 1, 'plum': 1}),
        5: Counter({'cherry': 1}),
        6: Counter({'pineapple': 1}),
        7: Counter({'apricot': 1})
    }
}


# Initialize CategoryCounter and update with a list of items
def test_initialize_and_update_with_list():
    # Arrange
    counter = CategoryCounter()

    # Act
    counter.update(fruits)

    # Assert
    assert counter.total == expected_total


# Categorize items using direct category values
def test_categorize_with_direct_category_values():
    # Arrange
    counter = CategoryCounter()

    # Act
    for fruit in fruits:
        counter.update({fruit: 1}, char_count=len(fruit), unique_char_count=len(set(fruit)))

    # Assert
    assert counter.total == expected_total
    assert counter == expected_counter


# Categorize items using functions to determine categories
def test_categorize_with_functions():
    # Arrange
    counter = CategoryCounter()

    # Act
    for fruit in fruits:
        counter.update({fruit: 1},
                       char_count=lambda s: len(next(iter(s))),
                       unique_char_count=lambda s: len(set(next(iter(s)))))

    # Assert
    assert counter.total == expected_total
    assert counter == expected_counter


# Retrieve counts for specific categories
def test_retrieve_counts_for_specific_categories():
    # Arrange
    counter = CategoryCounter()
    expected = expected_total

    # Act
    counter.update(fruits, type='fruit')

    # Assert
    assert counter['type']['fruit'] == expected


# Update with an empty list
def test_update_with_empty_list():
    # Arrange
    counter = CategoryCounter()

    # Act
    counter.update([])

    # Assert
    assert counter.total == Counter()


# Provide static category
def test_categories_not_matching_any_items():
    # Arrange
    counter = CategoryCounter()

    # Act
    counter.update(fruits, type='fruit')

    # Assert
    assert counter['type']['car'] == Counter()


# Update with mixed data types
def test_update_with_mixed_data_types():
    # Arrange
    counter = CategoryCounter()
    data = ['apple', 1, 2.5, 1, 1]

    # Act & Assert
    # with pytest.raises(TypeError):
    counter.update(data)

    assert counter.total == Counter({'apple': 1, 1: 3, 2.5: 1})


# Verify initialization without any updates
def test_initialization_without_updates():
    # Arrange & Act
    counter = CategoryCounter()

    # Assert
    assert counter.total == Counter()


# Check behavior with nested data structures
def test_nested_data_structures_behavior():
    # Arrange
    counter = CategoryCounter()
    data = [{'name': 'apple'}, {'name': 'banana'}, {'name': 'apple'}]

    # Act & Assert
    with pytest.raises(TypeError):
        counter.update(data)


# Correctly formats the string representation of CategoryCounter
def test_correct_formatting():
    # Arrange
    counter = CategoryCounter()

    # Act
    result = repr(counter)

    # Assert
    assert result == "CategoryCounter({})"
