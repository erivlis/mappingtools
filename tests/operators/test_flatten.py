# Generated by Qodo Gen
import random

import pytest

from mappingtools.operators import flatten

flatten_cases = [
    ({}, {}, {}),
    ({'a': {'b': {'c': 1}, 'd': 2}}, {('a', 'b', 'c'): 1, ('a', 'd'): 2}, {'a.b.c': 1, 'a.d': 2})
]


# Flatten a nested dictionary into a single-level dictionary with tuple keys
@pytest.mark.parametrize(('nested_dict', 'expected_tuple_keys', 'expected_str_keys'), flatten_cases)
def test_flatten_nested_dict(nested_dict, expected_tuple_keys, expected_str_keys):
    # Act
    actual_tuple_keys = flatten(nested_dict)
    actual_str_keys = flatten(nested_dict, '.')

    # Assert
    assert actual_tuple_keys == expected_tuple_keys
    assert actual_str_keys == expected_str_keys


# Handle dictionaries with varying depths of nesting
def test_varying_depths():
    # Arrange
    nested_dict = {'a': {'b': 2}, 'c': {'d': {'e': 3}}}
    expected = {('a', 'b'): 2, ('c', 'd', 'e'): 3}

    # Act
    result = flatten(nested_dict)

    # Assert
    assert result == expected


# Process dictionaries with non-string keys
def test_non_string_keys():
    # Arrange
    nested_dict = {1: {2: {3: 'value'}}}
    expected = {(1, 2, 3): 'value'}

    # Act
    result = flatten(nested_dict)

    # Assert
    assert result == expected


# Return an empty dictionary when given an empty dictionary
def test_empty_dictionary():
    # Arrange
    nested_dict = {}
    expected = {}

    # Act
    result = flatten(nested_dict)

    # Assert
    assert result == expected


# Maintain the order of elements as they appear in the original dictionary
def test_maintain_order():
    # Arrange
    nested_dict = {'a': {'b': 1}, 'c': {'d': 2}}
    expected = {('a', 'b'): 1, ('c', 'd'): 2}

    # Act
    result = flatten(nested_dict)

    # Assert
    assert list(result.keys()) == list(expected.keys())


# Handle dictionaries with circular references
def test_circular_references():
    # Arrange
    nested_dict = {}
    nested_dict['a'] = nested_dict

    # Act & Assert
    with pytest.raises(RecursionError):
        flatten(nested_dict)


# Process dictionaries with mixed data types as values
def test_mixed_data_types():
    # Arrange
    nested_dict = {'a': {'b': 1, 'c': [2, 3], 'd': None}}
    expected = {('a', 'b'): 1, ('a', 'c'): [2, 3], ('a', 'd'): None}

    # Act
    result = flatten(nested_dict)

    # Assert
    assert result == expected


# Handle dictionaries with keys that are not hashable
def test_non_hashable_keys():
    # Arrange
    nested_dict = {('a',): {'b': 1}}
    expected = {('a', 'b'): 1}

    # Act
    result = flatten(nested_dict)

    # Assert
    assert result == expected


# Process dictionaries with large data sizes efficiently
def test_large_data_size():
    # Arrange
    range_1 = random.randint(100, 200)
    range_2 = random.randint(100, 200)
    large_dict = {i: {j: i * 10 + j for j in range(range_2)} for i in range(range_1)}

    # Act & Assert (no exception should be raised)
    try:
        actual = flatten(large_dict)
        assert actual is not None
        assert len(actual) == range_2 * range_1
        assert actual[(0, 0)] == 0
        assert actual[(range_1 - 1, range_2 - 1)] == (range_1 - 1) * 10 + range_2 - 1

    except Exception:
        pytest.fail("Function raised an exception on large data size")


# Handle dictionaries with deeply nested structures
def test_deeply_nested_structures():
    # Arrange
    nested_dict = {'a': {'b': {'c': {'d': {'e': 5}}}}}
    expected = {('a', 'b', 'c', 'd', 'e'): 5}

    # Act
    result = flatten(nested_dict)

    # Assert
    assert result == expected


# Ensure the function is idempotent when applied multiple times
def test_idempotency():
    # Arrange
    nested_dict = {'a': {'b': 1}}

    # Act
    first_result = flatten(nested_dict)
    second_result = flatten(first_result)

    # Assert
    assert first_result == second_result


# Validate the function's behavior with dictionaries containing special characters in keys
def test_special_characters_in_keys():
    # Arrange
    nested_dict = {'a!@#': {'b$%^': 1}}
    expected = (('a!@#', 'b$%^'), 1)

    # Act
    result = flatten(nested_dict)

    # Assert
    assert next(iter(result.items())) == expected
