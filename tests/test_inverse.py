# Generated by CodiumAI
from mappingtools import inverse


#  Inverting a mapping with unique sets of values
def test_invert_unique_sets():
    # Arrange
    mapping = {'a': {1}, 'b': {2}, 'c': {3}}

    # Act
    result = inverse(mapping)

    # Assert
    assert result == {1: {'a'}, 2: {'b'}, 3: {'c'}}


#  Processing an empty mapping
def test_invert_empty_mapping():
    # Arrange
    mapping = {}

    # Act
    result = inverse(mapping)

    # Assert
    assert result == {}


#  Inverting a mapping with single-element sets
def test_invert_single_element_sets():
    # Arrange
    mapping = {'a': {1}, 'b': {2}}

    # Act
    result = inverse(mapping)

    # Assert
    assert result == {1: {'a'}, 2: {'b'}}


#  Handling mappings with non-string keys and values
def test_invert_non_string_keys_values():
    # Arrange
    mapping = {1: {2}, 3: {4}}

    # Act
    result = inverse(mapping)

    # Assert
    assert result == {2: {1}, 4: {3}}


#  Inverting a mapping with empty sets
def test_invert_empty_sets():
    # Arrange
    mapping = {'a': set(), 'b': set()}

    # Act
    result = inverse(mapping)

    # Assert
    assert result == {}


#  Handling mappings with nested sets
def test_invert_nested_sets():
    # Arrange
    mapping = {'a': {frozenset({1, 2})}, 'b': {frozenset({3, 4})}}

    # Act
    result = inverse(mapping)

    # Assert
    assert result == {frozenset({1, 2}): {'a'}, frozenset({3, 4}): {'b'}}


#  Inverting a mapping with mixed data types in sets
def test_invert_mixed_data_types():
    # Arrange
    mapping = {'a': {1, 'x'}, 'b': {2, 'y'}}

    # Act
    result = inverse(mapping)

    # Assert
    assert result == {1: {'a'}, 'x': {'a'}, 2: {'b'}, 'y': {'b'}}


#  Handling mappings with duplicate values across different sets
def test_invert_duplicate_values_across_sets():
    # Arrange
    mapping = {'a': {1, 2}, 'b': {2, 3}}

    # Act
    result = inverse(mapping)

    # Assert
    assert result == {1: {'a'}, 2: {'a', 'b'}, 3: {'b'}}


#  Handling large mappings efficiently
def test_invert_large_mappings():
    # Arrange
    max_i = 1000
    max_j = 100
    mapping = {i: {i + j for j in range(1, max_j)} for i in range(1, max_i)}

    # Act
    result = inverse(mapping)

    # Assert
    for i in range(1, max_i):
        for j in range(1, max_j):
            assert i + j in result
            assert i in result[i + j]


#  Ensuring the order of keys in the resulting dictionary is consistent
def test_invert_order_consistency():
    # Arrange
    mapping = {'a': {1, 2}, 'b': {3, 4}}

    # Act
    result = inverse(mapping)

    # Assert
    expected_order = [(1, {'a'}), (2, {'a'}), (3, {'b'}), (4, {'b'})]
    assert list(result.items()) == expected_order


#  Handling mappings with complex nested structures
def test_invert_complex_nested_structures():
    # Arrange
    mapping = {
        'a': {frozenset({1, frozenset({2, 3})})},
        'b': {frozenset({4, frozenset({5, 6})})}
    }

    # Act
    result = inverse(mapping)

    # Assert
    assert result == {
        frozenset({1, frozenset({2, 3})}): {'a'},
        frozenset({4, frozenset({5, 6})}): {'b'}
    }
