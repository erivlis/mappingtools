# Generated by Qodo Gen

from mappingtools.transformers.minify import minify


# Minify a simple dictionary with string keys
def test_minify_simple_dictionary():
    # Arrange
    original = {"name": "John", "age": 30, "city": "New York"}

    # Act
    result = minify(original)

    # Assert
    assert len(result) == 3
    assert all(isinstance(k, str) and len(k) == 1 for k in result)
    assert set(result.values()) == set(original.values())


# Minify a nested dictionary with multiple levels
def test_minify_nested_dictionary():
    # Arrange
    original = {
        "user": {
            "personal": {
                "name": "John",
                "age": 30
            },
            "address": {
                "city": "New York",
                "zip": "10001"
            }
        }
    }
    expected = {'A': {'B': {'C': 'John', 'D': 30}, 'E': {'F': 'New York', 'G': '10001'}}}

    # Act
    actual = minify(original)

    # Assert
    assert actual == expected


# Minify a list of dictionaries
def test_minify_list_of_dictionaries():
    # Arrange
    original = [
        {"name": "John", "age": 30},
        {"name": "Jane", "age": 25},
        {"name": "Bob", "age": 40}
    ]

    # Act
    result = minify(original)

    # Assert
    assert isinstance(result, list)
    assert len(result) == 3
    for item in result:
        assert isinstance(item, dict)
        assert len(item) == 2
        assert all(len(k) == 1 for k in item)
    # Check that all original values are preserved
    original_ages = [d["age"] for d in original]
    result_ages = [d[next(k for k in d if d[k] in original_ages)] for d in result]
    assert sorted(original_ages) == sorted(result_ages)


# Minify a class object with attributes
def test_minify_class_object():
    # Arrange
    class Person:
        def __init__(self):
            self.name = "John"
            self.age = 30
            self.city = "New York"

    original = Person()
    expected = {'A': 30, 'B': 'New York', 'C': 'John'}

    # Act
    actual = minify(original)

    # Assert
    assert actual == expected


# Minify with default alphabet (uppercase ASCII)
def test_minify_default_alphabet():
    # Arrange
    import string
    original = {
        "first": 1,
        "second": 2,
        "third": 3,
        "fourth": 4
    }

    # Act
    result = minify(original)

    # Assert
    assert len(result) == 4
    assert all(k in string.ascii_uppercase for k in result)
    assert all(len(k) == 1 for k in result)
    assert set(result.values()) == {1, 2, 3, 4}


# Verify consistent key mapping (same input key always maps to same output key)
def test_consistent_key_mapping():
    # Arrange
    original = {
        "name": "John",
        "age": 30,
        "city": "New York"
    }

    # Act
    result1 = minify(original)
    # Create a mapping of original keys to minified keys
    key_mapping = {}
    for orig_key, value in original.items():
        for mini_key, mini_value in result1.items():
            if mini_value == value:
                key_mapping[orig_key] = mini_key
                break

    # Minify again with same input
    result2 = minify(original)

    # Assert
    assert result1 == result2
    # Check that each original key maps to the same minified key in both results
    for orig_key, value in original.items():
        mini_key = key_mapping[orig_key]
        assert result2[mini_key] == value


# Minify an empty dictionary
def test_minify_empty_dictionary():
    # Arrange
    original = {}

    # Act
    result = minify(original)

    # Assert
    assert isinstance(result, dict)
    assert len(result) == 0


# Minify with custom alphabet (lowercase letters)
def test_minify_custom_alphabet():
    # Arrange
    import string

    from mappingtools.transformers.minify import minify
    original = {
        "name": "John",
        "age": 30,
        "city": "New York"
    }

    # Act
    result = minify(original, alphabet=string.ascii_lowercase)

    # Assert
    assert len(result) == 3
    assert all(k in string.ascii_lowercase for k in result)
    assert all(len(k) == 1 for k in result)
    assert set(result.values()) == set(original.values())


# Minify with very small alphabet (e.g., just 'AB')
def test_minify_small_alphabet():
    # Arrange
    original = {
        "first": 1,
        "second": 2,
        "third": 3,
        "fourth": 4,
        "fifth": 5,
        "sixth": 6
    }
    small_alphabet = "AB"

    # Act
    result = minify(original, alphabet=small_alphabet)

    # Assert
    assert len(result) == 6
    # With only 2 characters, we should have keys of length 1, 2, and 3
    assert all(all(c in small_alphabet for c in k) for k in result)
    # Check that we have the expected key lengths
    key_lengths = [len(k) for k in result]
    assert key_lengths.count(1) == 2  # A, B
    assert key_lengths.count(2) >= 1  # AA, AB, BA, BB
    assert set(result.values()) == {1, 2, 3, 4, 5, 6}


# Minify object with many keys that exceed single character representation
def test_minify_many_keys():
    # Arrange

    # Create a dictionary with more keys than available in the alphabet
    expected_size = 50
    original = {f"key_{i}": i for i in range(expected_size)}  # More than 26 keys

    expected = {'A': 0, 'AA': 26, 'AB': 27, 'AC': 28, 'AD': 29, 'AE': 30, 'AF': 31, 'AG': 32, 'AH': 33, 'AI': 34,
                'AJ': 35, 'AK': 36, 'AL': 37, 'AM': 38, 'AN': 39, 'AO': 40, 'AP': 41, 'AQ': 42, 'AR': 43, 'AS': 44,
                'AT': 45, 'AU': 46, 'AV': 47, 'AW': 48, 'AX': 49, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'G': 6,
                'H': 7, 'I': 8, 'J': 9, 'K': 10, 'L': 11, 'M': 12, 'N': 13, 'O': 14, 'P': 15, 'Q': 16, 'R': 17, 'S': 18,
                'T': 19, 'U': 20, 'V': 21, 'W': 22, 'X': 23, 'Y': 24, 'Z': 25}
    # Act
    actual = minify(original)

    # Assert
    assert len(actual) == expected_size
    assert actual == expected


# Minify with non-string keys (integers, tuples)
def test_minify_non_string_keys():
    # Arrange
    original = {
        1: 'one',
        (2, 3): 'tuple',
        4.5: 'float'
    }

    expected = {'A': 'one', 'B': 'tuple', 'C': 'float'}

    # Act
    actual = minify(original)

    # Assert
    assert actual == expected


# Minify deeply nested structures with many levels
def test_minify_deeply_nested_structure():
    # Arrange
    original = {
        "level1": {
            "level2a": {
                "level3a": {
                    "level4a": {
                        "level5a": "deep value 1"
                    }
                }
            },
            "level2b": {
                "level3b": [
                    {"item1": "list value 1"},
                    {"item2": "list value 2"}
                ]
            }
        }
    }

    expected = {
        'A': {
            'B': {'C': {'D': {'E': 'deep value 1'}}},
            'F': {'G': [{'H': 'list value 1'}, {'I': 'list value 2'}]}
        }
    }

    # Act
    actual = minify(original)

    # Assert
    assert actual == expected
