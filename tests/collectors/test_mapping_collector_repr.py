# Generated by CodiumAI
import pytest

from mappingtools.aggregation import Aggregation
from mappingtools.collectors import MappingCollector


# Correct string representation for mode ALL
def test_repr_mode_all():
    # Arrange
    collector = MappingCollector(aggregation=Aggregation.ALL)
    collector.add('key1', 'value1')
    collector.add('key2', 'value2')

    # Act
    result = repr(collector)

    # Assert
    expected = "MappingCollector(aggregation=Aggregation.ALL, mapping={'key1': ['value1'], 'key2': ['value2']})"
    assert result == expected


# Correct string representation for mode COUNT
def test_repr_mode_count():
    # Arrange
    collector = MappingCollector(aggregation=Aggregation.COUNT)
    collector.add('key1', 'value1')
    collector.add('key2', 'value2')

    # Act
    result = repr(collector)

    # Assert
    expected = (
        "MappingCollector("
        "aggregation=Aggregation.COUNT, "
        "mapping={'key1': Counter({'value1': 1}), 'key2': Counter({'value2': 1})}"
        ")"
    )
    assert result == expected


# Correct string representation for mode DISTINCT
def test_repr_mode_distinct():
    # Arrange
    collector = MappingCollector(aggregation=Aggregation.DISTINCT)
    collector.add('key1', 'value1')
    collector.add('key2', 'value2')

    # Act
    result = repr(collector)

    # Assert
    expected = "MappingCollector(aggregation=Aggregation.DISTINCT, mapping={'key1': {'value1'}, 'key2': {'value2'}})"
    assert result == expected


# Correct string representation for mode FIRST
def test_repr_mode_first():
    # Arrange
    collector = MappingCollector(aggregation=Aggregation.FIRST)
    collector.add('key1', 'value1')
    collector.add('key2', 'value2')

    # Act
    result = repr(collector)

    # Assert
    expected = "MappingCollector(aggregation=Aggregation.FIRST, mapping={'key1': 'value1', 'key2': 'value2'})"
    assert result == expected


# Correct string representation for mode LAST
def test_repr_mode_last():
    # Arrange
    collector = MappingCollector(aggregation=Aggregation.LAST)
    collector.add('key1', 'value1')
    collector.add('key2', 'value2')

    # Act
    result = repr(collector)

    # Assert
    expected = "MappingCollector(aggregation=Aggregation.LAST, mapping={'key1': 'value1', 'key2': 'value2'})"
    assert result == expected


# Handling of invalid mode
def test_invalid_mode():
    # Arrange / Act / Assert
    with pytest.raises(TypeError):
        MappingCollector(aggregation="INVALID_MODE")


# Empty internal mapping representation
def test_empty_internal_mapping():
    # Arrange
    collector = MappingCollector(aggregation=Aggregation.ALL)

    # Act
    result = repr(collector)

    # Assert
    expected = "MappingCollector(aggregation=Aggregation.ALL, mapping={})"
    assert result == expected


# Large internal mapping representation
def test_large_internal_mapping():
    # Arrange
    collector = MappingCollector(aggregation=Aggregation.ALL)
    for i in range(1000):
        collector.add(f'key{i}', f'value{i}')

    # Act
    result = repr(collector)

    # Assert
    expected_start = "MappingCollector(aggregation=Aggregation.ALL, mapping={"
    assert result.startswith(expected_start)
    assert len(result) > len(expected_start)


# Special characters in keys and values
def test_special_characters_in_keys_and_values():
    # Arrange
    collector = MappingCollector(aggregation=Aggregation.ALL)
    special_key = "spￃﾩcial_kￃﾩy!@#"
    special_value = "spￃﾩcial_vￃﾠlue!@#"
    collector.add(special_key, special_value)

    # Act
    result = repr(collector)

    # Assert
    expected = f"MappingCollector(aggregation=Aggregation.ALL, mapping={{'{special_key}': ['{special_value}']}})"
    assert result == expected


# Nested data structures in internal mapping
def test_nested_data_structures_in_internal_mapping():
    # Arrange
    collector = MappingCollector(aggregation=Aggregation.ALL)
    nested_value = {'nested_key': ['nested_value']}
    collector.add('key', nested_value)

    # Act
    result = repr(collector)

    # Assert
    expected = f"MappingCollector(aggregation=Aggregation.ALL, mapping={{'key': [{nested_value}]}})"
    assert result == expected


# Consistency of __repr__ output with internal state changes
def test_consistency_with_internal_state_changes():
    # Arrange
    collector = MappingCollector(aggregation=Aggregation.ALL)

    # Act & Assert - Initial state
    initial_result = repr(collector)
    initial_expected = "MappingCollector(aggregation=Aggregation.ALL, mapping={})"
    assert initial_result == initial_expected

    # Act & Assert - After adding elements
    collector.add('key1', 'value1')
    updated_result = repr(collector)
    updated_expected = "MappingCollector(aggregation=Aggregation.ALL, mapping={'key1': ['value1']})"
    assert updated_result == updated_expected


# Performance with large mappings
def test_performance_with_large_mappings():
    import time

    # Arrange
    collector = MappingCollector(aggregation=Aggregation.ALL)

    for i in range(10000):
        collector.add(f'key{i}', f'value{i}')

    start_time = time.time()

    # Act
    result = repr(collector)

    end_time = time.time()

    # Assert - Ensure it completes within a reasonable time frame (e.g., 1 second)
    assert len(result) > 0
    assert (end_time - start_time) < 1.0
