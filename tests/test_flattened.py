# Generated by Qodo Gen

from mappingtools import flattened


# Flatten a nested dictionary into a single-level dictionary with tuple keys
def test_flatten_nested_dict():
    # Arrange
    nested_dict = {'a': {'b': {'c': 1}}}
    expected = {('a', 'b', 'c'): 1}

    # Act
    result = flattened(nested_dict)

    # Assert
    assert result == expected


# Handle dictionaries with varying depths of nesting
def test_varying_depths():
    # Arrange
    nested_dict = {'a': {'b': 2}, 'c': {'d': {'e': 3}}}
    expected = {('a', 'b'): 2, ('c', 'd', 'e'): 3}

    # Act
    result = flattened(nested_dict)

    # Assert
    assert result == expected


# Process dictionaries with non-string keys
def test_non_string_keys():
    # Arrange
    nested_dict = {1: {2: {3: 'value'}}}
    expected = {(1, 2, 3): 'value'}

    # Act
    result = flattened(nested_dict)

    # Assert
    assert result == expected


# Return an empty dictionary when given an empty dictionary
def test_empty_dictionary():
    # Arrange
    nested_dict = {}
    expected = {}

    # Act
    result = flattened(nested_dict)

    # Assert
    assert result == expected


# Maintain the order of elements as they appear in the original dictionary
def test_maintain_order():
    # Arrange
    nested_dict = {'a': {'b': 1}, 'c': {'d': 2}}
    expected = {('a', 'b'): 1, ('c', 'd'): 2}

    # Act
    result = flattened(nested_dict)

    # Assert
    assert list(result.keys()) == list(expected.keys())


# Handle dictionaries with circular references
def test_circular_references():
    # Arrange
    nested_dict = {}
    nested_dict['a'] = nested_dict

    # Act & Assert
    try:
        flattened(nested_dict)
        assert False, "Expected a RecursionError"
    except RecursionError:
        assert True


# Process dictionaries with mixed data types as values
def test_mixed_data_types():
    # Arrange
    nested_dict = {'a': {'b': 1, 'c': [2, 3], 'd': None}}
    expected = {('a', 'b'): 1, ('a', 'c'): [2, 3], ('a', 'd'): None}

    # Act
    result = flattened(nested_dict)

    # Assert
    assert result == expected


# Handle dictionaries with keys that are not hashable
def test_non_hashable_keys():
    # Arrange
    nested_dict = {('a',): {'b': 1}}
    expected = {('a', 'b'): 1}

    # Act
    result = flattened(nested_dict)

    # Assert
    assert result == expected


# Process dictionaries with large data sizes efficiently
def test_large_data_size():
    # Arrange
    large_dict = {i: {j: j for j in range(100)} for i in range(100)}

    # Act & Assert (no exception should be raised)
    try:
        flattened(large_dict)
        assert True
    except Exception:
        assert False, "Function failed on large data size"


# Handle dictionaries with deeply nested structures
def test_deeply_nested_structures():
    # Arrange
    nested_dict = {'a': {'b': {'c': {'d': {'e': 5}}}}}
    expected = {('a', 'b', 'c', 'd', 'e'): 5}

    # Act
    result = flattened(nested_dict)

    # Assert
    assert result == expected


# Ensure the function is idempotent when applied multiple times
def test_idempotency():
    # Arrange
    nested_dict = {'a': {'b': 1}}

    # Act
    first_result = flattened(nested_dict)
    second_result = flattened(first_result)

    # Assert
    assert first_result == second_result


# Validate the function's behavior with dictionaries containing special characters in keys
def test_special_characters_in_keys():
    # Arrange
    nested_dict = {'a!@#': {'b$%^': 1}}
    expected = (('a!@#', 'b$%^'), 1)

    # Act
    result = flattened(nested_dict)

    # Assert
    assert list(result.items())[0] == expected
